{"meta":{"title":"安卓","subtitle":"","description":"","author":"BTPIG","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2021-07-25T12:27:44.000Z","updated":"2021-07-25T12:28:46.008Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-07-25T12:27:21.000Z","updated":"2021-07-25T12:28:25.406Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"安卓-广播机制","slug":"安卓-广播机制","date":"2021-08-21T08:53:39.000Z","updated":"2021-08-21T09:44:14.519Z","comments":true,"path":"2021/08/21/安卓-广播机制/","link":"","permalink":"http://example.com/2021/08/21/%E5%AE%89%E5%8D%93-%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/","excerpt":"全局大喇叭—详解广播机制","text":"全局大喇叭—详解广播机制 1.广播机制简介1.1简介Android的广播机制类似于IP地址中的最大地址，最大IP地址可以发送消息并被同一网络上的所有主机收到。 但Android的中应用程序能对自己所感兴趣的广播进行注册，这样程序就能根据兴趣标签筛选出自己所关心的广播， 这样就不用接受所有广播的信息。 1.2分类Android中的广播可以主要分为两种类型：标准广播和有序广播。 标准广播是一种完全异步执行的广播，在广播发出之后，所有的广播接收器几乎都会在同一时刻接受到这条广播消息，因此它们之间没有任何先后顺序可言，这种广播的效率会比较高，但同时也意味着它是无法被拦截的。 有序广播则是一种同步执行的广播，在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。所以此时的广播接受器是有先后顺序的，优先级高的广播接收器就可以先收到广播消息，并且前面的广播接收器还可以截断正在传递的广播，这样后面的广播接收器就无法收到广播消息了。 2.接收系统广播Android内置了很多级别的广播，我们可以在应用程序中监听这些广播来得到各种系统的状态信息，因此就需要用到广播接收器，它分为动态注册和静态注册两种。 2.1动态注册12345678910111213141516171819202122232425 private TestBroadcastReceiver receiver; @Override protected void onCreate() &#123; super.onCreate(); receiver = new TestBroadcastReceiver(); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(&quot;test.broadcast&quot;);//广播的action registerReceiver(receiver,intentFilter);//注册广播，通常时在Activity OnCreate的时候 //也可以不编写BroadcastReceiver的子类TestBroadcastReceiver直接使用匿名内部类的方式创建Receiver receiver = new BroadcastReceiver()&#123; @Override public void onReceive(Context context, Intent intent) &#123; //处理接收到广播后的逻辑 &#125; &#125;;&#125; @Override protected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(receiver);//在onDesdory的时候取消广播的注册，防止内存泄漏 &#125; 需要注意动态注册的广播接收者优先级永远比静态注册的广播接收者要高，静态注册的广播接收者则生命周期要比动态注册的要长。Android 8.0之后对广播的静态注册做了限制，自定义的广播接收者静态注册的时候会收不到广播。为了程序安全谷歌建议开发者使用动态注册。如果一定要静态注册一对一广播可以在发送广播的时候给intent设置目标app的包名,这样就可以收到了。 2.2静态注册​ 静态注册在AndroidManifest.xml文件中修改 1234567&lt;receiver android:name=&quot;.BootReceiver&quot; android:exported=&quot;true&quot; android:enabled=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;XXXXXXXX&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 和活动注册非常类似，通过android:name来指定注册哪一个广播接收器，而enabled和exported属性则是根据我们刚才勾选的状态自动生成的，action标签则是对系统的指定动作进行筛选并接收信息。 3.发送自定义广播3.1发送标准广播 标准广播是一种完全异步执行的广播，在广播发出之后，所有的广播接收器几乎都会在同一时刻接受到这条广播消息，因此它们之间没有任何先后顺序可言，这种广播的效率会比较高，但同时也意味着它是无法被拦截的。 3.2发送有序广播 有序广播则是一种同步执行的广播，在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。所以此时的广播接受器是有先后顺序的，优先级高的广播接收器就可以先收到广播消息，并且前面的广播接收器还可以截断正在传递的广播，这样后面的广播接收器就无法收到广播消息了。 有序广播通过sendOrderedBroadcast方法发送 12Intent intent = new Intent(&quot;test.broadcast&quot;); sendOrderedBroadcast(intent,null); 第二个参数为启动权限，设置为null也就是不添加权限 3.2.1有序广播动态注册12345receiver = new TestBroadcastReceiver();IntentFilter intentFilter = new IntentFilter();intentFilter.addAction(&quot;test.broadcast&quot;);intentFilter.setPriority(999);registerReceiver(receiver,intentFilter); 3.2.2标准广播静态注册12345receiver = new TestBroadcastReceiver();IntentFilter intentFilter = new IntentFilter();intentFilter.addAction(&quot;test.broadcast&quot;);intentFilter.setPriority(999);registerReceiver(receiver,intentFilter); 4.使用本地广播注册接收者 12345678 localBroadcastManager = LocalBroadcastManager.getInstance(this);Intent intent = new Intent(&quot;test.broadcast&quot;); //发送本地广播 localBroadcastManager.sendBroadcast(intent); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(&quot;test.broadcast&quot;); LocalReceiver localReceiver = new LocalReceiver(); localBroadcastManager.registerReceiver(localReceiver, intentFilter); 本地广播无法通过静态注册接收，但是在静态注册的时候receiver标签下有android:exported=”true”属性，设置为true就是允许接收其他进程发送的广播，false则只接收本地的。和本地广播的功能很相似。","categories":[],"tags":[]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2021-07-25T12:12:00.000Z","updated":"2021-08-21T09:43:47.983Z","comments":true,"path":"2021/07/25/我的第一篇博客/","link":"","permalink":"http://example.com/2021/07/25/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"我的博客编写","text":"我的博客编写 第一篇 Hello world !!!!! 第二篇 Hello people!!!!! 参考文献 我的第一个hexo教程 本主题使用教程 主题高级配置 图片不能引用解决","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-07-25T11:30:28.216Z","updated":"2021-08-20T03:53:32.848Z","comments":true,"path":"2021/07/25/hello-world/","link":"","permalink":"http://example.com/2021/07/25/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}